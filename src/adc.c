#include "adc.h"
uint8_t lcdChange = 0;
uint16_t lcdCount = 0;
uint8_t lcdCheck = 0;
//float battery;

uint16_t adcValue[4] = { 0, 0, 0, 0};
void adc_Init(void) {

	/*	 RCC -> CFGR |= (0X06<14); // MAKING SURE PRESCALER DOES NOT EXCEED 14MHZ
	 RCC -> APB2ENR |= 1<<9;  // ENABLE CLOCK FOR ADC1 IN RCC REGISTER
	 RCC -> APB2ENR |= 1<<0; // ENABLE ALTERNATE FUNCTION;
	 RCC -> AHBENR |= 1<<0;  // ENABLE DMA1

	 GPIOA -> CRL &= ~(0X0F << 0 );  // SETTING PINA0 AS ANALOG INPUT
	 //GPIOA -> CRL |= (0X00 << 0 );  // SETTING PINA0 AS ANALOG INPUT

	 GPIOA -> CRL &= ~(0X0F << 4 );  // SETTING PINA1 AS ANALOG INPUT
	 //GPIOA -> CRL |= (0X00 << 4 );  // SETTING PINA1 AS ANALOG INPUT

	 GPIOA -> CRL &= ~(0X0F << 8 );  // SETTING PINA1 AS ANALOG INPUT
	 //GPIOA -> CRL |= (0X00 << 8 );  // SETTING PINA2 AS ANALOG INPUT
	 //GPIOA -> CRL &= ~(0X0F << 12 );  // SETTING PINA3 AS ANALOG INPUT
	 GPIOA -> CRL &= ~(0X0F << 16 );  // SETTING PINA4 AS ANALOG INPUT
	 //GPIOA -> CRL &= ~(0X0F << 20 );  // SETTING PINA5 AS ANALOG INPUT
	 //GPIOA -> CRL &= ~(0X0F << 24 );  // SETTING PINA6 AS ANALOG INPUT
	 //ADC1 -> CR1 |= 1<<5; // ENABLE END OF CONVERSION INTERRUPT

	 //NVIC_EnableIRQ(ADC1_2_IRQn); //ENABLE INTERRPUT IN NVIC


	 ADC1 -> SMPR2 |= (7<<0); // SETTING THE SAMPLE RATE A0
	 ADC1 -> SMPR2 |= (7<<3); // SETTING THE SAMPLE RATE A1
	 ADC1 -> SMPR2 |= (7<<6); // SETTING THE SAMPLE RATE A2
	 //ADC1 -> SMPR2 |= (7<<9); // SETTING THE SAMPLE RATE A3
	 //ADC1 -> SMPR2 |= (7<<12); // SETTING THE SAMPLE RATE A4
	 //ADC1 -> SMPR2 |= (7<<15); // SETTING THE SAMPLE RATE A4

	 ADC1 -> SQR1 |= (3 << 20); //

	 ADC1 -> SQR3 |= (0 <<0); // SETTING CHANNEL 0 IN THE SEQUECE REGISTER
	 ADC1 -> SQR3 |= (1 <<5); // SETTING CHANNEL 1 IN THE SEQUECE REGISTER
	 ADC1 -> SQR3 |= (2 <<10); // SETTING CHANNEL 2 IN THE SEQUECE REGISTER
	 //ADC1 -> SQR3 |= (3 <<15); // SETTING CHANNEL 3 IN THE SEQUECE REGISTER
	 //ADC1 -> SQR3 |= (4 <<20); // SETTING CHANNEL 4 IN THE SEQUECE REGISTER
	 //ADC1 -> SQR3 |= (5 <<25); // SETTING CHANNEL 4 IN THE SEQUECE REGISTER

	 ADC1 -> CR1 |= (1<<8);  // PUTS THE ADC IN SCAN MODE
	 ADC1 -> CR2 |= (1<<8); // 1<<8        ENABLE DMA FOR ADC

	 DMA1_Channel1 -> CPAR = (uint32_t)(&(ADC1->DR));
	 DMA1_Channel1 -> CMAR = (uint32_t)adcValue;
	 DMA1_Channel1 -> CNDTR = 4;
	 DMA1_Channel1 -> CCR |= (5<<5);
	 DMA1_Channel1 -> CCR |= (1<<8);
	 DMA1_Channel1 -> CCR |= (1<<10);
	 DMA1_Channel1 -> CCR |= (1<<0);

	 ADC1 -> CR2 |= (3<<0);  // ENABLE ADON BIT AND SET IT IN CONTINUOUS MODE

	 delay_ms(1);

	 ADC1 -> CR2 |= (1<<0);

	 delay_ms(1);

	 ADC1 -> CR2 |= (1<<2);   // ENABLE THE CALIBRATION
	 delay_ms(50);
	 */

	RCC->CFGR |= (0X00 < 14); // MAKING SURE PRESCALER DOES NOT EXCEED 14MHZ
	RCC->APB2ENR |= 1 << 9;  // ENABLE CLOCK FOR ADC1 IN RCC REGISTER
	RCC->APB2ENR |= 1 << 0; // ENABLE ALTERNATE FUNCTION;
	RCC->AHBENR |= 1 << 0;  // ENABLE DMA1

	GPIOA->CRL &= ~(0X0F << 0);  // SETTING PINA0 AS ANALOG INPUT
	GPIOA->CRL &= ~(0X0F << 4);  // SETTING PINA1 AS ANALOG INPUT
	//GPIOA->CRL &= ~(0X0F << 8);  // SETTING PINA2 AS ANALOG INPUT
	//GPIOA->CRL &= ~(0X0F << 12);  // SETTING PINA3 AS ANALOG INPUT
	GPIOA->CRL &= ~(0X0F << 16); // PA4
	GPIOA->CRL &= ~(0X0F << 20);// PA5
	//GPIOA->CRL &= ~(0X0F << 24);// PA6
	//ADC1 -> CR1 |= 1<<5; // ENABLE END OF CONVERSION INTERRUPT

	//NVIC_EnableIRQ(ADC1_2_IRQn); //ENABLE INTERRPUT IN NVIC

	ADC1->SMPR2 |= (7 << 0); // SETTING THE SAMPLE RATE
	ADC1->SMPR2 |= (7 << 3); // SETTING THE SAMPLE RATE
	//ADC1->SMPR2 |= (7 << 6); // SETTING THE SAMPLE RATE A2
	//ADC1->SMPR2 |= (7 << 9); // SETTING THE SAMPLE RATE A2
	ADC1->SMPR2 |= (7 << 12);
	ADC1->SMPR2 |= (7 << 15);
	//ADC1 -> SMPR2 |= (7<<18);

	ADC1->SQR1 |= (0X03 << 20); // SETTING THE NUMBER OF LENGHT, SINCE WE ARE WORKING ON JUST ONE CHANNEL THE DEFAULT IS SET TO 1 CHANNEL

	ADC1->SQR3 |= (0 << 0); // SETTING CHANNEL 0 IN THE SEQUECE REGISTER
	ADC1->SQR3 |= (1 << 5); // SETTING CHANNEL 1 IN THE SEQUECE REGISTER
	ADC1->SQR3 |= (4 << 10); // SETTING CHANNEL 4 IN THE SEQUECE REGISTER
	ADC1->SQR3 |= (5 << 15); //  SETTING CHANNEL 5 IN THE SEQUECE REGISTER
	//ADC1->SQR3 |= (1 << 20);
	//ADC1->SQR3 |= (2 << 25);
	//ADC1 -> SQR2 |= (6 <<0);

	ADC1->CR1 |= (1 << 8);  // PUTS THE ADC IN SCAN MODE
	ADC1->CR2 |= ADC_CR2_DMA; // 1<<8        ENABLE DMA FOR ADC

	DMA1_Channel1->CPAR = (uint32_t) (&(ADC1->DR));
	DMA1_Channel1->CMAR = (uint32_t) adcValue;
	DMA1_Channel1->CNDTR = 4;
	DMA1_Channel1->CCR |= (5 << 5);
	DMA1_Channel1->CCR |= (1 << 8);
	DMA1_Channel1->CCR |= (1 << 10);
	DMA1_Channel1->CCR |= (1 << 0);

	ADC1->CR2 |= (3 << 0);  // ENABLE ADON BIT AND SET IT IN CONTINUOUS MODE

	delay_ms(1);

	ADC1->CR2 |= (1 << 0);

	delay_ms(1);

	ADC1->CR2 |= (1 << 2);   // ENABLE THE CALIBRATION
	delay_ms(50);
}